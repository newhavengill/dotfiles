# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# If this file loaded already, don't do anything
[ -n "$BASH_LOADED" ] && return

# Many utilities assume you have a ~/tmp directory.
[ -d "$HOME/tmp" ] || echo "WARNING: Missing $HOME/tmp directory." >&2

# This needs to be local. Do not export.
BASH_LOADED=1

# Convinience method to check if a command exists or not.
command_exists () {
    hash "$1" &> /dev/null
}

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# CTRL-D will logout of shell after 2 tries (ignore 1st CTRL-D)
IGNOREEOF=1

# allow CTRL-S to work
stty stop undef

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

prompt() {
    case "$1" in
        simple)
            PS1='${debian_chroot:+($debian_chroot)}\u@\h:\W\$ '
            ;;
        color)
            PS1='${debian_chroot:+($debian_chroot)}\[\e[34m\]\u\[\e[0m\]@\h:\[\e[36m\]\W\[\e[0m\]\$ '
            ;;
        multi*)
            PS1='\n[\!] `if [ $? = 0 ]; then echo \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[31m\]O.O\[\e[0m\]; fi` \u@\h:\[\e[36m\]\w\[\e[0m\]\n\$ ${debian_chroot:+($debian_chroot)}~> '
            ;;
        emot*)
            PS1='`if [ $? = 0 ]; then echo \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[31m\]O.O\[\e[0m\]; fi`${debian_chroot:+($debian_chroot)} [\u@\h:\[\e[36m\]\W\[\e[0m\]]\$ '
            ;;
        def*)
            prompt color
            return
            ;;
        *)
            echo "Usage prompt <option>"
            echo "  default    Defaults to color"
            echo "  simple     username@hostname:current_dir$"
            echo "  multiline  a multilined emotive prompt"
            echo "  emotive    ^_^ [username@hostname:current_dir]$"
            return
            ;;
    esac
    # Fix PS1 if git-completion module was loaded
    if command_exists "__git_ps1" ; then
        if echo "$PS1" | grep -v __git_ps1 > /dev/null 2>&1; then
            case "$1" in
                emot*|color)
                    PS1=$(echo "$PS1" | sed -e 's/\\\$ */\$(__git_ps1 " (\\[\\e[33m\\]%s\\[\\e[0m\\])")\\\$ /')
                    ;;
                multi*)
                    PS1=$(echo "$PS1" | sed -e 's/\\n\\\$/\$(__git_ps1 " (\\[\\e[33m\\]%s\\[\\e[0m\\])")\\n\\\$/')
                    ;;
                *)
                    PS1=$(echo "$PS1" | sed -e 's/\\\$ */\$(__git_ps1 " (%s)")\\\$ /')
                    ;;
            esac
        fi
    fi
}

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \W\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Find bash_loader repository directory
if [ -z "$BASH_LOADER_HOME" ]; then
    if command_exists "readlink" ; then
        BASH_LOADER_HOME=$(dirname "$(readlink $HOME/.bash_loader)")
        BASH_LOADER_HOME=$(cd "$BASH_LOADER_HOME/.." && pwd)
    elif test -d "${HOME}/.dotty/default/dotfiles" ; then
        BASH_LOADER_HOME="${HOME}/.dotty/default/dotfiles"
    else
        BASH_LOADER_HOME="${HOME}"
    fi
    export BASH_LOADER_HOME
fi

# Utility functions to manipulate the PATH.
# Used to prevent duplicates on multiple calls.
inPath() {
    echo "${PATH}" | grep "$1" > /dev/null
}
notInPath() {
    if inPath "$1"; then
        return 1
    else
        return 0
    fi
}
addToPath() {
    if notInPath "$1"; then
        PATH="${PATH}:$1"
    fi
    export PATH
}
prependToPath() {
    if notInPath "$1"; then
        PATH="$1:${PATH}"
    fi
    export PATH
}

# A util function to setup missing file paths that some programs and scrips
# expect.
setupTempPaths() {
    mkdir -p ~/tmp
    mkdir -p ~/tmp/sessions
    touch ~/.tmux.conf.local
    mkdir -p ~/vim
    touch ~/.vim/local.vim
    touch ~/.vim/local_gui.vim
    touch .bash_aliases
}

# Modules
# Loading of other bash modules
load_bash_modules() {
    case "$1" in
        -q|--quiet)
            local quiet=1
            ;;
        -h|--help)
            echo "Usage: load_bash_modules [-q|--quiet]"
            return
            ;;
    esac
    if [ -e "$HOME/.bash_modules" ]; then
        local mod_path="${BASH_LOADER_HOME}/bash_modules.d"
        local mod_files=$(sed -e 's/#.*//' -e 's/[ 	]*$//' -e 's/^[ 	]*//' -e '/^$/ d' "$HOME/.bash_modules")
        local OLDIFS="${IFS}"
        IFS=$'\n'
        for confline in $mod_files; do
            if [ -r "${mod_path}/${confline}" ]; then
                source "${mod_path}/${confline}"
                [[ $quiet ]] || echo "Loaded ${confline}"
            else
                [[ $quiet ]] || echo "Not found: ${mod_path}/${confline}"
            fi
        done
        IFS="${OLDIFS}"
    fi
    if [ -d "$HOME/.bash_modules.d" ]; then
        for module in $HOME/.bash_modules.d/*; do
            source "${module}"
            [[ $quiet ]] || echo "Loaded $(basename "$module")"
        done
    fi
}

load_bash_modules --quiet

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    # PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\W\[\033[00m\]\$ '
    prompt default
else
    prompt simple
fi
unset color_prompt force_color_prompt

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

# Instalation specific config
if [ -f "$HOME/.bash_local" ]; then
    . "$HOME/.bash_local"
elif [ -f "$HOME/.local_bashrc" ]; then
    # Deprecated
    . "$HOME/.local_bashrc"
fi

# vim:set ft=sh sw=4 ts=8 et fdm=marker :
